<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<title>Life</title>
		<script src="prototype.js" type="text/javascript"></script>
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden; font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

		</style>
	</head>
	<body>
		<div>
			<canvas id="canvas" style="width: 100%; height: 100%;"></canvas>
		</div>
		<script id="vertexShader" type="x-shader/x-vertex">
			uniform mat4 world;
			uniform mat4 projection;
			uniform float phase;
			attribute vec4 position;
			varying vec2 coord;
			void main()
			{
				coord = (position.xy + 1.0) /  2.0;
				gl_Position = world * projection * position;
			}
		</script>
		<script id="identityShader" type="x-shader/x-vertex">
			uniform float phase;
			attribute vec4 position;
			varying vec2 coord;
			void main()
			{
				coord = (position.xy + 1.0) /  2.0;
				gl_Position = position;
			}
		</script>
		<script id="randomFrag" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif
			varying vec2 coord;
			uniform vec3 seed;

			float rand(vec2 co){
				//stolen from http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
			    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
			}

			void main(void)
			{
				float noize_r = rand(coord + seed[0]);
				float noize_g = rand(coord + seed[1]);
				float noize_b = rand(coord + seed[2]);
				float dist = distance(coord, vec2(0.5,0.5));
				gl_FragColor = step( 0.6-dist,vec4(noize_r, noize_g, noize_b, 1.0));
			}
		</script>
		<script id="lifeFrag" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif
			varying vec2 coord;
			uniform vec2 resolution;
			uniform sampler2D backbuffer;
			uniform float phase;

			void main(void)
			{   
				vec4 sumNeighbors = vec4(0.0,0.0,0.0,0.0);
				sumNeighbors += texture2D(backbuffer, coord + vec2(-1.0,-1.0)/resolution);
				sumNeighbors += texture2D(backbuffer, coord + vec2(-1.0, 0.0)/resolution);
				sumNeighbors += texture2D(backbuffer, coord + vec2(-1.0, 1.0)/resolution);
				sumNeighbors += texture2D(backbuffer, coord + vec2( 0.0,-1.0)/resolution);
				sumNeighbors += texture2D(backbuffer, coord + vec2( 0.0, 1.0)/resolution);
				sumNeighbors += texture2D(backbuffer, coord + vec2( 1.0,-1.0)/resolution);
				sumNeighbors += texture2D(backbuffer, coord + vec2( 1.0, 0.0)/resolution);
				sumNeighbors += texture2D(backbuffer, coord + vec2( 1.0, 1.0)/resolution);

				vec4 cellState = texture2D(backbuffer, coord);

				for (int i = 0; i < 3; i++) {
					if (cellState[i] > 0.5) {
						//live
						if (sumNeighbors[i] < 1.5)
							gl_FragColor[i] = 0.0;
						else if (sumNeighbors[i] > 1.5 && sumNeighbors[i] < 3.5)
							gl_FragColor[i] = 1.0;
						else 
							gl_FragColor[i] = 0.0;
					}
					else {
						//dead
						if (sumNeighbors[i] > 2.5 && sumNeighbors[i] < 3.5)
							gl_FragColor[i] = 1.0;
						else
							gl_FragColor[i] = 0.0;
					}
				}
			}
		</script>
		<script id="screenFrag" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif
			varying vec2 coord;
			uniform sampler2D frontbuffer;

			void main(void)
			{
				gl_FragColor = texture2D(frontbuffer, coord);
			}
		</script>

		<script type="text/javascript" src="js/threedlibrary/tdl/base.js"></script>
		<script type="text/javascript" src="js/stats.js/src/Stats.js"></script>
		<script type="text/javascript">
			tdl.require('tdl.buffers');
			tdl.require('tdl.framebuffers');
			tdl.require('tdl.fast');
			tdl.require('tdl.clock');
			tdl.require('tdl.log');
			tdl.require('tdl.math');
			tdl.require('tdl.misc');
			tdl.require('tdl.models');
			tdl.require('tdl.primitives');
			tdl.require('tdl.programs');
			tdl.require('tdl.textures');
			tdl.require('tdl.webgl');

			window.onload = init;

			var gl, model, screenProgram, lifeProgram, frontBuffer, backBuffer;

			var quality = 1.0;
			var width = 4096;
			var height = 2048;
			var zoom = 1.0;
			var focus = [0,0,0];

			function scaleViewport() {
				canvas.width = window.innerWidth * quality;
				canvas.height = window.innerHeight * quality;
				console.log("Resized to: " + canvas.width + "x" + canvas.height);
				gl.drawingBufferHeight = canvas.height;
				gl.drawingBufferWidth = canvas.width;
				gl.viewport(0,0,canvas.width, canvas.height);
			}

			function loadRandomness(buffer) {

				sq= square();

				randomProgram = tdl.programs.loadProgramFromScriptTags('vertexShader','randomFrag');
				randomModel = new tdl.models.Model(randomProgram, sq, null);

				buffer.bind();
				seed = new Float32Array([Math.random(), Math.random(), Math.random()]);
				world = projection = tdl.fast.identity4(new Float32Array(16));
				randomModel.drawPrep();
				randomModel.draw({world: world, projection: projection, seed: seed});
				buffer.unbind();
			}

			function setUpStats() {
				if (Stats == undefined) return;
				var stats = new Stats();
				stats.getDomElement().style.position = 'absolute';
				stats.getDomElement().style.left = '0px';
				stats.getDomElement().style.top = '0px';

				document.body.appendChild( stats.getDomElement() );
				return stats;
			}

			function wheelzoom(evt) {
				zoom += zoom * evt.wheelDelta / 1000.0;
			}
			
			function focusmouse(evt) {
				focus[0] = - ( evt.clientX / window.innerWidth ) * 2 + 1;
				focus[1] = ( evt.clientY / window.innerHeight ) * 2 - 1;
			}

			function init() {
				canvas = document.getElementById("canvas");
				gl = tdl.webgl.setupWebGL(canvas);

				window.onresize = scaleViewport;

				document.addEventListener( 'mousewheel', wheelzoom, false );
				document.addEventListener( 'mousemove', focusmouse, false );

				scaleViewport();

				var stats = setUpStats();


				var frontBuffer = new tdl.framebuffers.Framebuffer(width,height);
				frontBuffer.texture.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				//frontBuffer.texture.setParameter(gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				frontBuffer.texture.setParameter(gl.TEXTURE_WRAP_S, gl.REPEAT);
				frontBuffer.texture.setParameter(gl.TEXTURE_WRAP_T, gl.REPEAT);
				var backBuffer = new tdl.framebuffers.Framebuffer(width,height);
				backBuffer.texture.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				//backBuffer.texture.setParameter(gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				backBuffer.texture.setParameter(gl.TEXTURE_WRAP_S, gl.REPEAT);
				backBuffer.texture.setParameter(gl.TEXTURE_WRAP_T, gl.REPEAT);

				var projection = new Float32Array(16);
				var view = new Float32Array(16);
				var world = new Float32Array(16);
				var eyePosition = new Float32Array(3);
				var clock = tdl.clock.createClock();
				var resolution = new Float32Array([width, height]);


				var uniforms = {
					projection: projection,
					resolution: resolution,
					world: world
				};



				tdl.fast.matrix4.ortho(projection, -1, 1, -1, 1, 0, -1);

				sq = square();
				lifeProgram = tdl.programs.loadProgramFromScriptTags('identityShader','lifeFrag');
				lifeModel = new tdl.models.Model(lifeProgram, sq, null);

				screenProgram = tdl.programs.loadProgramFromScriptTags('vertexShader','screenFrag');
				screenModel = new tdl.models.Model(screenProgram, sq, null);

				loadRandomness(backBuffer);

				function render() {
					tdl.webgl.requestAnimationFrame(render, canvas);

					gl.colorMask(true, true, true, true);
					gl.depthMask(true);
					gl.clearColor(0,0,0,0);
					gl.clearDepth(1);
					gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

					gl.enable(gl.CULL_FACE);
					gl.enable(gl.DEPTH_TEST);

					//compute new uniforms
					uniforms.phase = clock.getTime() % (2 * Math.PI);
					uniforms.backbuffer = backBuffer.texture;
					uniforms.frontbuffer = frontBuffer.texture;

					tdl.fast.matrix4.scaling(world, [zoom, zoom, zoom]);
					tdl.fast.matrix4.translate(world, focus);
					
					//draw new frontbuffer
					frontBuffer.bind();
					lifeModel.drawPrep();
					lifeModel.draw(uniforms);
					frontBuffer.unbind();

					//draw the frontbuffer to the screen
					screenModel.drawPrep();
					screenModel.draw(uniforms);

					//swap buffers
					tmp = backBuffer;
					backBuffer = frontBuffer;
					frontBuffer = tmp;

					stats.update();

				}
				render();
				return true;
			}

			function square() {
				var positions = new tdl.primitives.AttribBuffer(4, 4);
				var indices = new tdl.primitives.AttribBuffer(3, 2, 'Uint16Array');
				positions.push([-1.0 , -1.0 , 0.0 , 1.0]);
				positions.push([-1.0 , 1.0 , 0.0 , 1.0]);
				positions.push([1.0 , -1.0 , 0.0 , 1.0]);
				positions.push([1.0 , 1.0 , 0.0 , 1.0]);
				indices.push([0,2,1]);
				indices.push([1,2,3]);
				return {
					position: positions,
					indices: indices
				}
			}

		</script>
	</body>
</html>

